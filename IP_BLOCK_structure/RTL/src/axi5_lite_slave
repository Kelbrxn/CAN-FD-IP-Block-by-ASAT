module axi5_lite_slave (
parameter DATA_WIDTH = 32,
parameter DEPTH = 256,
parameter ADDR_WIDTH = $clog2(DEPTH)
)(
    //global signals
    input   logic                       ACLK,
    input   logic                       ARESETn,




    //write address channel
    input  logic                        AWVALID,
    output logic                        AWREADY,
    input  logic                        AWID,
    input  logic [ADDR_WIDTH-1:0]       AWADDR,
    input  logic                        AWPROT,

    //write data channel
    input  logic                        WVALID,
    output logic                        WREADY,
    input  logic [DATA_WIDTH-1:0]       WDATA,
    input  logic [(DATA_WIDTH/8)-1:0]   WSTRB,

    //write response channel
    output logic                        BVALID,
    input  logic                        BREADY,
    output logic                        BID,

    //read address channel
    input  logic                        ARVALID,
    output logic                        ARREADY,
    input  logic                        ARID,
    input  logic [ADDR_WIDTH-1:0]       ARADDR,

    //read data channel
    output logic                        RVALID,
    input  logic                        RREADY,
    output logic                        RID,
    output logic [DATA_WIDTH-1:0]       RDATA
);


//memory declaration
logic [DATA_WIDTH-1:0] mem [0:DEPTH-1];

//write address channel
assign AWREADY = 1'b1;

//write data channel
assign WREADY  = 1'b1;

//write response channel
assign BID     = AWID;

always_ff @(posedge ACLK or negedge ARESETn) begin
    if (!ARESETn) begin
        BVALID <= 1'b0;
    end else begin
        if (AWVALID && WVALID && !BVALID) begin
            //write operation
            mem[AWADDR] <= WDATA;
            BVALID <= 1'b1;
        end else if (BVALID && BREADY) begin
            BVALID <= 1'b0;
        end
    end
end
//read address channel
assign ARREADY = 1'b1;
//read data channel
assign RID     = ARID;
always_ff @(posedge ACLK or negedge ARESETn) begin
    if (!ARESETn) begin
        RVALID <= 1'b0;
        RDATA  <= '0;
    end else begin
        if (ARVALID && !RVALID) begin
            //read operation
            RDATA  <= mem[ARADDR];
            RVALID <= 1'b1;
        end else if (RVALID && RREADY) begin
            RVALID <= 1'b0;
        end
    end
end

endmodule