module axi4_lite_slave #(
        parameter ADDRESS = 32,
        parameter DATA_WIDTH = 32
)   (
        //global signals
        input                         ACLK,
        input                         ARESETn,

        //read address channel
        input      [ADDRESS-1:0]      ARADDR,
        input                         ARVALID,
        output                        ARREADY,

        //read data channel
        input                         RREADY,
        output                        RVALID,
        output     [DATA_WIDTH-1:0]   RDATA,
        output     [1:0]              RRESP,

        //write address channel
        input      [ADDRESS-1:0]      AWADDR,
        input                         AWVALID,
        output                        AWREADY,
        //write data channel
        input      [DATA_WIDTH-1:0]   WDATA,
        input                         WVALID,
        input     [DATA_WIDTH/8-1:0]  WSTRB,
        output                        WREADY,

        //write response channel
        input                         BREADY,
        output                        BVALID,
        output     [1:0]              BRESP
    );

    localparam number_of_registers = 32;

    logic [DATA_WIDTH-1:0] register [number_of_registers-1:0];
    logic [ADDRESS-1:0] addr;
    logic write_addr;
    logic write_data;

    typedef enum logic [2:0] {IDLE, WRITE_CHANNEL, WRESP_CHANNEL, READ_DATA_CHANNEL, READ_ADDR_CHANNEL} state_t;
    state_t state, next_state;

    // --- ASSIGNMENTS ---
    // Read Channel
    assign ARREADY = (state == READ_ADDR_CHANNEL);
    assign RVALID  = (state == READ_DATA_CHANNEL);
    // [FIX 1] Address Math: Use sliced address [ADDRESS-1:2] to convert byte address to word index
    assign RDATA   = (state == READ_DATA_CHANNEL) ? register[addr[ADDRESS-1:2]] : '0;
    assign RRESP   = 2'b00; // OKAY

    // Write Channel
    assign AWREADY = (state == WRITE_CHANNEL);
    assign WREADY  = (state == WRITE_CHANNEL);
    assign write_addr = AWVALID && AWREADY;
    assign write_data = WVALID && WREADY;

    assign BVALID  = (state == WRESP_CHANNEL);
    assign BRESP   = 2'b00; // OKAY

    integer i;

    // --- SEQUENTIAL LOGIC (Registers) ---
    always_ff @(posedge ACLK or negedge ARESETn) begin
        if (!ARESETn) begin
            for (i=0; i<32; i++) begin
                register[i] <= 32'b0;
            end
        end
        else begin
            if (state == WRITE_CHANNEL && write_addr && write_data) begin
                // [FIX 1] Address Math: Drop bottom 2 bits to index correctly (4 -> 1)
                register[AWADDR[ADDRESS-1:2]] <= WDATA;
            end
            else if (state == READ_ADDR_CHANNEL && ARVALID && ARREADY) begin
                addr <= ARADDR;
            end
        end
    end

    // --- SEQUENTIAL LOGIC (State Machine) ---
    // [FIX 2] Added async reset sensitivity to match the rest of the design
    always_ff @(posedge ACLK or negedge ARESETn) begin
        if (!ARESETn) begin
            state <= IDLE;
        end
        else begin
            state <= next_state;
        end
    end

    // --- COMBINATIONAL LOGIC (Next State) ---
    always_comb begin
        // [FIX 3] Default assignment prevents Latches
        next_state = state; 

        case (state)
            IDLE: begin
                if (AWVALID) begin
                    next_state = WRITE_CHANNEL;
                end
                else if (ARVALID) begin
                    next_state = READ_ADDR_CHANNEL;
                end
                else begin
                    next_state = IDLE;
                end
            end

            READ_ADDR_CHANNEL: begin
                if (ARVALID && ARREADY) next_state = READ_DATA_CHANNEL;
            end

            READ_DATA_CHANNEL: begin
                if (RVALID && RREADY) next_state = IDLE;
            end

            WRITE_CHANNEL: begin
                if (write_addr && write_data) next_state = WRESP_CHANNEL;
            end

            WRESP_CHANNEL: begin
                if (BVALID && BREADY) next_state = IDLE;
            end
        endcase
    end
endmodule
