module fifo #(
    parameter DATA_WIDTH = 8, // Changed to 8-bit for realism
    parameter DEPTH = 16      // FIFO depth
)(
    input  wire                  clk,
    input  wire                  rst_n,
    input  wire                  wr_en,
    input  wire                  rd_en,
    input  wire [DATA_WIDTH-1:0] data_in,  // Input Bus
    output reg  [DATA_WIDTH-1:0] data_out, // Output Bus
    output wire                  full,
    output wire                  empty
);

    // Internal memory and pointers
    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];
    reg [$clog2(DEPTH):0] wr_ptr; // Write pointer
    reg [$clog2(DEPTH):0] rd_ptr; // Read pointer
    reg [$clog2(DEPTH):0] count;  // How many items in FIFO

    // Status Flags
    assign full  = (count == DEPTH);
    assign empty = (count == 0);

    // Write Logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            wr_ptr <= 0;
        end else if (wr_en && !full) begin
            mem[wr_ptr] <= data_in;
            wr_ptr <= (wr_ptr == DEPTH-1) ? 0 : wr_ptr + 1;
        end
    end

    // Read Logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rd_ptr <= 0;
            data_out <= 0;
        end else if (rd_en && !empty) begin
            data_out <= mem[rd_ptr];
            rd_ptr <= (rd_ptr == DEPTH-1) ? 0 : rd_ptr + 1;
        end
    end

    // Counter Logic (to determine full/empty)
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            count <= 0;
        end else begin
            case ({wr_en && !full, rd_en && !empty})
                2'b10: count <= count + 1; // Write only
                2'b01: count <= count - 1; // Read only
                // 2'b11: Read and Write simultaneously -> Count stays same
            endcase
        end
    end
endmodule